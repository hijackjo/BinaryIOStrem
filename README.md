# BinaryIOStream
## 1. 什么是序列化与反序列化

序列化：将数据结构或对象转换成适合存储、传输的数据格式，如二进制。

反序列化：将在序列化过程中生成的二进制串还原成数据结构或对象的过程。

PC之间的通信、进程之间的通信，程序数据的存储都是以字节形式传递。例如程序中的对象想要发送给另一台主机，或存储到文件中时是以字节的形式存储，另一台主机不认识对象，只认识字节序列。所以发送方需要将具体的对象转换为字节流，即序列化，接收方将字节流恢复成对象，即反序列化。

同时，序列化与反序列化还能够达到跨语言的作用。发送方按照特定的格式生成发送一份数据，无论接收方是何种编程语言，只需要按照相应的格式读取字节数据，就能够生成自己的对象。

无论是在进程间通信、本地数据存储又或者是网络数据传输都离不开序列化的支持。而针对不同场景选择合适的序列化方案对于应用的性能有着极大的影响。下面是几种常见的序列化与反序列化协议：

## 2. 几种常见的序列化和反序列化协议

1. XML&SOAP
2. JSON
3. **Protobuf**
4. Boost的Serialization
# 3. 程序介绍
1. 文件BinaryIOStream.cpp 是一个协议序列化和反序列化的类。写了一个测试文件，Client文件夹里是客户端，Server文件夹里是服务端。客户端和服务端建立了一个TCP连接，客户端发送一个登陆请求，服务端接受请求后，把内容打印出来，就结束了。
    登陆请求：
        //status: 在线状态 0离线 1在线 2忙碌 3离开 4隐身
        //clienttype: 客户端类型,pc=1, android=2, ios=3
        cmd = 1002, seq = 0, {"username": "13917043329", "password": "123", "clienttype": 1, "status": 1}
   客户端
   ![image](https://github.com/hijackjo/BinaryIOStrem/assets/46513183/79d75841-1f16-4572-aa61-7046a8347b37)

   服务端
    ![image](https://github.com/hijackjo/BinaryIOStrem/assets/46513183/0d4a30f2-8a15-488d-8f6a-93d5457bce06)

3. 通过重载输出流运算符 << 和输入流运算符的形式实现数据的写入和读取

## 3. 不知道怎么解决的问题
1. 在重载输入流<< 运算符的时候，返回值是BinaryStreamReader对象本身，且只能有两个参数。所以原来老师的代码里的return false这种，判断错误的逻辑，不知道怎么写，就都空着了。如下图
   ![image](https://github.com/hijackjo/BinaryIOStrem/assets/46513183/e584aa8a-2897-4b3d-90f7-ecb2fbfef7fd)

3. 写得太烂了，为了不增加代码的复杂程度，就没有合并成一个类了。

## 4. 遇到的坑
1. string的内存布局
   刚开始我想的很简单，不理解，为什么BinaryStreamReader的数据成员不能和BinaryStreamWriter一样，用一个string * m_data;来接收。所以服务端在接受到登陆请求的时候，我把数据放到一个inbuf里面。从第7个字节开始读取，怎么读都都不到正确的客户端发送过来的数据。调试了一个星期，gdb vs 各种调试，打断点，看内存，白天调试晚上emo（真的好菜啊）。就是收不到正确的数据，可是客户端明明发送过来了。
   在我的理解里，string和C风格的字符串一样，是栈上的空间。后来查资料，知道了string在linux里是32个字节，头八个字节是指向堆空间的地址，数据放在堆上。难怪我一直在string的栈空间里找数据找不到。
   所以我觉得BinaryStreamReader的数据成员必须是用指针的形式以C风格的字符串来接收。
